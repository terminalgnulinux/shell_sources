#!/bin/bash

source me

# Inicialização
if types.__INIT__ 2>/dev/null; then
	return 1; fi

function types.__INIT__() { return 0; }
function types.__NAME__() { printf "%s\n" "$__VAR_LIBRARY__"; }
function types.__VAR__() { printf "%s\n" "${__VAR_METHOD__[*]}"; }
function types.__ARRAY__(){ printf "%s\n" "${__ARRAY_METHOD__[*]}" ; }
function types.__DICT__(){ printf "%s\n" "${__DICT_METHOD__[*]}"; }
function types.__STRUCT__(){ printf "%s\n" "${__STRUCT_METHOD__[*]}"; }

declare -rf types.__INIT__ types.__NAME__ types.__VAR__ types.__ARRAY__ types.__DICT__

# Constantes
declare -r __TYPES_LIBRARY__=types
declare -ar __VAR_METHOD__=(len reverse toupper tolower isalpha isdigit isalnum isspace islower isupper join count find replace mid swapcase value char squeeze left right repeat clear)
declare -ar __ARRAY_METHOD__=(len max min list count append index insert remove reverse sort clear listindex comp copy item)
declare -ar __DICT_METHOD__=(keys add items existskey values update copy clear)
declare -ar __STRUCT_METHOD__=(add remove list values copy type)

function var()
{
	function var.__INIT__()
	{	
		local LINE=$BASH_LINENO
		local FUNC=$FUNCNAME
		local VarName
		local Method

		for VarName in $*; do
			if ! unset $VarName 2>/dev/null; then
				error_exit $LINE $FUNC "'$VarName' Não é um identificador válido ou somente leitura."; fi
			for Method in ${__VAR_METHOD__[*]}; do
			eval "function $VarName.$Method(){ LINE=\$BASH_LINENO; FUNC=\$FUNCNAME; var.$Method $VarName \$*; }"; done
			eval "function $VarName.del(){ LINE=\$BASH_LINENO; FUNC=\$FUNCNAME; var.__DEL__ \"$VarName\"; }"
			eval "function $VarName.type(){ printf '%s\n' 'VAR'; }"
			
			eval "declare -g $VarName"
		done
	
		
		return 0
	}
	
	function var.__DEL__()
	{
		local LINE=$BASH_LINENO
		local FUNC=$FUNCNAME
		local Method
		local VarName 
			
		for VarName in $*; do
			if [ "$($VarName.type 2>/dev/null)" != "VAR" ]; then
				error_exit $LINE $FUNC "'$VarName' Não é do tipo 'var'."; fi

			for Method in ${__VAR_METHOD__[*]}; do
				if ! unset -f $VarName.$Method 2>/dev/null; then
					error_exit $LINE $FUNC "'$VarName.$Method' Método somente leitura."; fi; done

			if ! unset -v $VarName 2>/dev/null; then
				error_exit $LINE $FUNC "'$VarName' Variável somente leitura."; fi
		done
		
		return 0
	}
	

	
	local LINE=$BASH_LINENO
	local FUNC=$FUNCNAME
	
	if [ ! "$*" ]; then
		error_exit $LINE $FUNC "Requer identificador da variável."; else
			var.__INIT__ $*; fi
	
	return 0	
}

# --------------------------------------------------------------------------------------------- #
 
function array(){

	function array.__INIT__()
	{
		local LINE=$BASH_LINENO
		local FUNC=$FUNCNAME
		local ArrayName
		local Method

		for ArrayName in $*; do
			if ! unset $ArrayName 2>/dev/null; then
				error_exit $LINE $FUNC "'$ArrayName' Não é um identificador válido ou somente leitura."; fi
			for Method in ${__ARRAY_METHOD__[*]}; do
				eval "function $ArrayName.$Method(){ LINE=\$BASH_LINENO; FUNC=\$FUNCNAME; array.__$Method \"$ArrayName\" \$*; }"
			done
			eval "function $ArrayName.del(){ LINE=\$BASH_LINENO; FUNC=\$FUNCNAME; array.__DEL__ \"$ArrayName\"; }"
			eval "function $ArrayName.type(){ printf '%s\n' 'ARRAY'; }"
			
			eval "declare -ag $ArrayName"
		done
		
		return 0
	}
	
	function array.__DEL__()
	{
		local LINE=$BASH_LINENO
		local FUNC=$FUNCNAME
		local Array Method

		for Array in $*; do
			if [ "$($Array.type)" != "ARRAY" ]; then
				error_exit $LINE $FUNC "'$Array' Não é do tipo 'array'."; fi

			for Method in ${__ARRAY_METHOD__[*]}; do
				if ! unset -f $Array.$Method 2>/dev/null; then
					error_exit $LINE $FUNC "'$Array.$Method' Método somente leitura."; fi; done

			if ! unset -v $Array 2>/dev/null; then
				error_exit $LINE $FUNC "'$Array' Array somente leitura."; fi
		done
		
		return 0
	}

	function array.__len()
	{
		if [ ${#*} -gt 2 ]; then
			error_exit $LINE $FUNC "'${*:3}' Excesso de argumentos."
		elif [ $2 ]; then
			if [[ "$2" != ?(+)+([0-9]) ]]; then
				error_exit $LINE $FUNC "'Indice' Deve ser um inteiro positivo."
			fi
		fi
				
		declare -n VarRef="$1"
		declare Index="$2"

		[ "$Index" ] && printf "%d\n" ${#VarRef[$Index]} || printf "%d\n" ${#VarRef[*]}

		return 0
	}
	
	function array.__max()
	{		
		if [ ${#*} -gt 1 ]; then
			error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."; fi

		declare -n VarRef="$1"
		
		# Imprime a quantidade de elementos	
		printf "%s\n" "${VarRef[$(echo ${!VarRef[*]} | sed 's/ /\n/g' | awk 'END {print}')]}"
		return 0
	}
	
	function array.__min()
	{		
		if [ ${#*} -gt 1 ]; then
			error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."; fi

		declare -n VarRef="$1"
		
		# Imprime a quantidade de elementos	
		printf "%s\n" "${VarRef[$(echo ${!VarRef[*]} | sed 's/ /\n/g' | awk 'NR==1 {print}')]}"
		return 0
	}
	
	function array.__list()
	{
		if [ ${#*} -gt 1 ]; then
			error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."; fi

		declare -n VarRef="$1"
		printf "%s\n" "${VarRef[*]}"

		return 0
	}
	
	function array.__count()
	{
		if [ ${#*} -gt 2 ]; then
			error_exit $LINE $FUNC "'${*:3}' Excesso de argumentos."; fi
		
		declare -n VarRef="$1"
		declare Obj="$2"
		declare -i Index Count=0
		
		for Index in ${!VarRef[*]}; do
			[ "$Obj" == "${VarRef[$Index]}" ] && ((Count++)); done
	
		printf "%d\r\n" "$Count"
		
		return 0
	}

	function array.__append()
	{
		if [ ${#*} -gt 2 ]; then
			error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."; fi
		
		declare -n VarRef="$1"
		declare Obj="$2"
		declare -i Index=$(echo ${!VarRef[*]} | sed 's/ /\n/g' | awk 'END {print}')

		((Index++))	
		VarRef[$Index]="$Obj"
		
		return 0
	}
	
	function array.__index()
	{
		if [ ${#*} -gt 2 ]; then
			error_exit $LINE $FUNC "'${*:3}' Excesso de argumentos."; fi
		
		declare -n VarRef="$1"
		declare Obj="$2"
		declare -i Index
		
		for Index in ${!VarRef[*]}; do
			if [ "$Obj" == "${VarRef[$Index]}" ]; then
				printf "%d\r\n" $Index; break; fi; done
		
		return 0
	}
	
	function array.__item()
	{
		if [ ${#*} -gt 2 ]; then
			error_exit $LINE $FUNC "'${*:3}' Excesso de argumentos."
		elif [[ ! "$2" || "$2" != ?(+)+([0-9]) ]]; then
				error_exit $LINE $FUNC "Index: Deve ser um inteiro positivo."
		fi
	
		declare -n VarRef="$1"
		declare -i Index="$2"
		
		printf "%s\r\n" "${VarRef[$Index]}"
	
		return 0
	}
		
	function array.__insert()
	{
		if [ ${#*} -gt 3 ]; then
			error_exit $LINE $FUNC "'${*:4}' Excesso de argumentos."
		elif [[ ! "$2" || "$2" != ?(+)+([0-9]) ]]; then
			error_exit $LINE $FUNC "Indice: Deve ser um inteiro positivo."
		fi			
		
		declare -n VarRef="$1"
		declare -i Index="$2"
		declare Obj="$3"
		
		VarRef[$Index]="$Obj"

		return 0
		
	}

	function array.__remove()
	{
		if [ ${#*} -gt 2 ]; then
			error_exit $LINE $FUNC "'${*:3}' Excesso de argumentos."; fi
		
		declare -n VarRef="$1"
		declare Obj="$2"
		declare -i Index
		
		for Index in ${!VarRef[*]}; do
			if [ "$Obj" == "${VarRef[$Index]}" ]; then
				unset VarRef[$Index]; break; fi; done
		
		return 0
	}
	
	function array.__reverse()
	{
		if [ ${#*} -gt 1 ]; then
			error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."; fi

		declare -n VarRef="$1"
		printf "%s$IFS" "${VarRef[*]}" | sed "s/$IFS/\n/g" | tac | sed -e :a -e "$!N;s/\n/$IFS/;ta" -e 'P;D'
		
		return 0
	}
	
	function array.__sort()
	{
		if [ ${#*} -gt 1 ]; then
			error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."; fi

		declare -n VarRef="$1"
		printf "%s$IFS" "${VarRef[*]}" | sed "s/$IFS/\n/g" | sort | sed -e :a -e "$!N;s/\n/$IFS/;ta" -e 'P;D'
		
		return 0
	}

	function array.__clear()
	{
		if [ ${#*} -gt 1 ]; then
			error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."
		elif ! unset "$1" 2>/dev/null; then
			error_exit $LINE $FUNC "Array somente leitura."; fi

		array "$1"

		return 0
	}
	
	function array.__listindex()
	{
		if [ ${#*} -gt 1 ]; then
			error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."; fi
		
		declare -n VarRef="$1"
		printf "%s\n" "${!VarRef[*]}"
	
		return 0
	}

	function array.__comp()
	{
		if [ ${#*} -gt 2 ]; then
			error_exit $LINE $FUNC "'${*:3}' Excesso de argumentos."; fi
		
		declare -n VarRef="$1" 
		declare -n VarRef2="$2"
		
		[ "${VarRef[*]}" == "${VarRef2[*]}" ] && echo "0" || echo "-1"
		
		return 0
	}

	function array.__copy()
	{
		if [ ${#*} -gt 2 ]; then
			error_exit $LINE $FUNC "'${*:3}' Excesso de argumentos."; fi
		
		declare -n VarRef="$1" 
		declare -n VarRef2="$2"
			
		VarRef2=(${VarRef[*]})
			
		return 0
	}
	
	local LINE=$BASH_LINENO
	local FUNC=$FUNCNAME
	
	if [ ! "$*" ]; then
		error_exit $LINE $FUNC "Requer identificador do array."; else
			array.__INIT__ $*; fi
	
	return 0	
}

# -------------------------------------------------------------------------------------------------------------#

function dict(){

	
	function dict.__INIT__()
	{
		local LINE=$BASH_LINENO
		local FUNC=$FUNCNAME
		local DictName
		local Method
		
		for DictName in $*; do
			if ! unset $DictName 2>/dev/null; then
				error_exit $LINE $FUNC "'$DictName' Não é um identificador válido ou somente leitura."; fi
			for Method in ${__DICT_METHOD__[*]}; do
				eval "function $DictName.$Method(){ LINE=\$BASH_LINENO; FUNC=\$FUNCNAME; dict.__$Method \"$DictName\" \$*; }"
			done
			eval "function $DictName.del(){ LINE=\$BASH_LINENO; FUNC=\$FUNCNAME; dict.__DEL__ \"$DictName\"; }"
			eval "function $DictName.type(){ printf '%s\n' 'DICT'; }"
			
			eval "declare -Ag $DictName"
		done
			
		return 0
	}
	
	function dict.__DEL__()
	{
		local LINE=$BASH_LINENO
		local FUNC=$FUNCNAME
		local Dict Method

		for Dict in $*;	do
			if [ "$($Dict.type)" != "DICT" ]; then
				error_exit $LINE $FUNC "'$Dict' Não é do tipo 'dicionário'."; fi

			for Method in ${__DICT_METHOD__[*]}; do
				if ! unset -f $Dict.$Method 2>/dev/null; then
					error_exit $LINE $FUNC "'$Dict.$Method' Método somente leitura."; fi; done

			if ! unset -v $Dict 2>/dev/null; then
				error_exit $LINE $FUNC "'$Dict' Dicionário somente leitura."; fi
		done
		
		return 0

	
	}

	function dict.__add()
	{
		if [ ${#*} -gt 3 ]; then
			error_exit $LINE $FUNC "'${*:4}' Excesso de argumentos."
		elif [ ! "$2" ]; then
			error_exit $LINE $FUNC "Chave: Não pode ser nula."
		fi
		
		declare -n DictRef="$1"
		declare Key="$2"
		declare Obj="$3"
		
		DictRef["$Key"]="$Obj"
		
		return 0
	}
	
	function dict.__items()
	{
		if [ ${#*} -gt 1 ]; then
			error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."; fi

		declare -n DictRef="$1"
		declare Key Value

		for Key in ${!DictRef[*]}; do
			printf "%s:%s$IFS" "$Key" "${DictRef["$Key"]}"; done | sed "s/$IFS$/\n/"
		
		return 0
	}
	
		
	function dict.__keys()
	{
		if [ ${#*} -gt 1 ]; then
			error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."; fi
	
		declare -n DictRef="$1"
		printf "%s\n" "${!DictRef[*]}"		
	
		return 0
	}
	
	function dict.__existskey()
	{
		if [ ${#*} -gt 2 ]; then
			error_exit $LINE $FUNC "'${*:3}' Excesso de argumentos."; fi
		
		declare -n DictRef="$1"
		declare Key="$2"
		
		[ $(printf "%s\n" "${!DictRef[*]}" | sed "s/$IFS/\n/g" | egrep -w -c "^$Key") -eq 1 ] && echo 0 || echo 1

		return 0

	}

	function dict.__values()
	{
		if [ ${#*} -gt 1 ]; then
			error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."; fi
		
		declare -n DictRef="$1"
		printf "%s\n" "${DictRef[*]}"

		return 0
	}

	function dict.__update()
	{
		if [ ${#*} -gt 2 ]; then
			error_exit $LINE $FUNC "'${*:3}' Excesso de argumentos."
		elif [ ! "$2" ]; then
			error_exit $LINE $FUNC "Dicionário: Não pode ser nulo."
		elif [ "$($2.type)" != "DICT" ]; then
			error_exit $LINE $FUNC "Dicionário: '$2' Tipo incompatível ou não existe."
		fi

		declare -n DictRef="$1"
		declare -n DictRef2="$2"
		declare Key
		
		for Key in ${!DictRef2[*]}; do
			DictRef["$Key"]="${DictRef2["$Key"]}"; done

		return 0
	}

	function dict.__copy()
	{
		if [ ${#*} -gt 2 ]; then
			error_exit $LINE $FUNC "'${*:3}' Excesso de argumentos."
		elif [ ! "$2" ]; then
			error_exit $LINE $FUNC "Dicionário: Não pode ser nulo."
		elif [ "$($2.type 2>/dev/null)" != "DICT" ]; then
			error_exit $LINE $FUNC "Dicionário: '$2' Tipo incompatível ou não existe."
		fi

		declare -n DictRef="$1"
		declare -n DictRef2="$2"
		declare Key
		
		$2.clear
		
		for Key in ${!DictRef[*]}; do
			DictRef2["$Key"]="${DictRef["$Key"]}"; done

		return 0
	}
	
	function dict.__clear()
	{
		if [ ${#*} -gt 1 ]; then
			error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."
		elif ! unset "$1" 2>/dev/null; then
				error_exit $LINE $FUNC "Dicionário somente leitura."; fi

		dict "$1"
		
		return 0
	}
	
	local LINE=$BASH_LINENO
	local FUNC=$FUNCNAME
	
	if [ ! "$*" ]; then
		error_exit $LINE $FUNC "Requer identificador do dicionário."; else
			dict.__INIT__ $*; fi
	
}

# --------------------------------------------------------------------------------------------------------

function struct()
{
	function struct.__INIT__()
	{
		local LINE=$BASH_LINENO
		local FUNC=$FUNCNAME
		local StructName
		local Method

		for StructName in $*; do
			if ! unset $StructName 2>/dev/null; then
				error_exit $LINE $FUNC "'$StructName' Não é um identificador válido ou somente leitura."; fi
			for Method in ${__STRUCT_METHOD__[*]}; do
      	 		eval "function $StructName.$Method(){ LINE=\$BASH_LINENO; FUNC=\$FUNCNAME; struct.__$Method \"$StructName\" \$*; }"
			done
			eval "function $StructName.del(){ LINE=\$BASH_LINENO; FUNC=\$FUNCNAME; struct.__DEL__ \"$StructName\"; }"
			eval "function $StructName.type(){ printf '%s\n' 'STRUCT'; }"
			
			eval "declare -g $StructName"
		done
			
		return 0
	}
	
	function struct.__DEL__()
	{
		local LINE=$BASH_LINENO
		local FUNC=$FUNCNAME
		local Struct Method

		for Struct in $*;	do
			if [ "$($Struct.type)" != "STRUCT" ]; then
				error_exit $LINE $FUNC "'$Struct' Não é do tipo 'estrutura'."; fi

			for Method in ${__STRUCT_METHOD__[*]}; do
				if ! unset -f $Struct.$Method 2>/dev/null; then
					error_exit $LINE $FUNC "'$Struct.$Method' Método somente leitura."; fi; done
			
			eval unset echo '${!struct_'$Struct'_*}'
		done
		
		return 0
	}

    function struct.__add()
    {
		local VarName Method

        for VarName in ${*:2}; do
			for Method in ${__STRUCT_METHOD__[*]}; do
				if [[ "$VarName" == "$Method" ]]; then
					error_exit $LINE $FUNC "'$VarName' Variável não pode ter nome de método."; fi; done
				eval "struct_$1_$VarName="
				eval "function $1.$VarName(){ LINE=\$BASH_LINENO; FUNC=\$FUNCNAME; struct.__SetOrGet struct_$1_$VarName \$*; }"
		done
		
		return 0
    }
	
	function struct.__remove()
	{
		declare StructName="$1"
		local VarName Method
		
		for VarName in ${*:2}; do
			for Method in ${__STRUCT_METHOD__[*]}; do
				if [[ "$VarName" == "$Method" ]]; then
					error_exit $LINE $FUNC "'$VarName' Método é somente leitura."; fi; done

			unset -f $StructName.$VarName
			unset struct_$StructName'_'$VarName
		done
	
		return 0
	}

    function struct.__SetOrGet()
    {
		if [ ${#*} -gt 3 ]; then
			error_exit $LINE $FUNC "'${*:4}' Excesso de argumentos."; fi
			
        declare -n VarRef="$1"
		declare Op="$2"
		declare Value="$3"
	
        if [[ "$Op" && "$Op" != "=" ]]; then
			error_exit $LINE $FUNC "'=' Requer operador de atribuição."
		elif [ ! "$Op" ]; then
        	printf "%s\n" "$VarRef"
        else
        	VarRef="$Value"
		fi
			
		return 0
    }

	function struct.__list()
	{
		declare StructName="$1"

		if [ ${#*} -gt 1 ]; then
			error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."; fi
		
		eval echo '${!struct_'$StructName'_*}' | sed "s/struct_//g;s/_/./g;s/ /$IFS/g"
		
		return 0
	}
	
	function struct.__values()
	{
		if [ ${#*} -gt 1 ]; then
			error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."; fi

		declare StructName="$1"
		eval echo "\"$(eval echo '${!struct_'$StructName'_*}' | sed "s/ /$IFS$/g;s/^/$/")\""
	
		return 0
	}

	function struct.__copy()
	{
		if [ ${#*} -gt 2 ]; then
			error_exit $LINE $FUNC "'${*:3}' Excesso de argumentos."
		elif [ ! "$2" ] ; then
			error_exit $LINE $FUNC "Estrutura: Não pode ser nulo."
		elif [ "$($2.type 2>/dev/null)" != "STRUCT" ]; then
			error_exit $LINE $FUNC "Estrutura: '$2' Tipo incompatível ou não existe."
		fi
			
		declare Struct1="$1" 
		declare Struct2="$2"
		
		for struct in $($Struct1.list); do
			Var="$(echo "$struct" | cut -d'.' -f2)";  $Struct2.add "$Var"
			eval "struct_$Struct2"_"$Var=\"\$struct_$Struct1"_"$Var"\"; done

		return 0
		
	}
	
	local LINE=$BASH_LINENO
	local FUNC=$FUNCNAME
	
	if [ ! "$*" ]; then
		error_exit $LINE $FUNC "Requer identificador da estrutura."; else
			struct.__INIT__ $*; fi
}
####################################################################################
# VAR
####################################################################################
function var.len()
{
	if [ ${#*} -gt 1 ]; then
		error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."; fi
	
	declare -n VarRef="$1"
	printf "%d\n" "${#VarRef}"
		
	return 0
}
	
function var.reverse()
{
	if [ ${#*} -gt 1 ]; then
		error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."; fi
	
	declare -n VarRef="$1"
	printf "%s\n" "$VarRef" | rev  
	
	return 0
}
	
function var.toupper()
{
	if [ ${#*} -gt 1 ]; then
		error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."; fi
	
	declare -n VarRef="$1"
	
	printf "%s\n" "$VarRef" | tr '[:lower:]' '[:upper:]'
		
	return 0
}
	
function var.tolower()
{
	if [ ${#*} -gt 1 ]; then
		error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."; fi
	
	declare -n VarRef="$1"
	
	printf "%s\n" "$VarRef" | tr '[:upper:]' '[:lower:]'
	
	return 0
}

function var.isalpha()
{
	if [ ${#*} -gt 1 ]; then
		error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."; fi
	
		declare -n VarRef="$1"
			
		[ ! "$(echo $VarRef | tr -d '[:alpha:]')" ] && echo 0 || echo 1
		
		return 0
}
	
function var.isdigit()
{
		if [ ${#*} -gt 1 ]; then
			error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."; fi
		
		declare -n VarRef="$1"
			
		[ ! "$(echo $VarRef | tr -d '[:digit:]')" ] && echo 0 || echo 1
		
		return 0
}
	
function var.isalnum()
{
		if [ ${#*} -gt 1 ]; then
			error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."; fi
		
		declare -n VarRef="$1"
			
		[ ! "$(echo $VarRef | tr -d '[:alnum:]')" ] && echo 0 || echo 1
		
		return 0
}
	
function var.isspace()
{
	if [ ${#*} -gt 1 ]; then
		error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."; fi
	
	declare -n VarRef="$1"
		
	[ ! "$(echo $VarRef | tr -d '[:blank:][:punct:]')" ] && echo 0 || echo 1
		
	return 0
}
	
function var.islower()
{
	if [ ${#*} -gt 1 ]; then
		error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."; fi
	
	declare -n VarRef="$1"
		
	[ ! "$(echo $VarRef | tr -d '[:lower:][:blank:][:punct:]')" ] && echo 0 || echo 1

	return 0
}	

function var.isupper()
{
	if [ ${#*} -gt 1 ]; then
		error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."; fi
	
	declare -n VarRef="$1"
		
	[ ! "$(echo $VarRef | tr -d '[:upper:][:blank:][:punct:]')" ] && echo 0 || echo 1
	
	return 0
}
	
function var.join()
{
	if [ ${#*} -gt 2 ]; then
		error_exit $LINE $FUNC "'${*:3}' Excesso de argumentos."; fi

	declare -n VarRef="$1"
	declare Obj="$2"
	
	VarRef+="$Obj"

	return 0
}

function var.count()
{
	# __count str start length
	if [ ${#*} -gt 4 ]; then
		error_exit $LINE $FUNC "'${*:5}' Excesso de argumentos."
	elif [[ "$3"  && "$3" != ?(+)+([0-9]) ]]; then
		error_exit $LINE $FUNC "Inicio: Precisa ser um inteiro positivo."
	elif [[ "$4"  && "$4" != ?(+)+([0-9]) ]]; then
		error_exit $LINE $FUNC "Comprimento: Precisa ser um inteiro positivo."
	fi
	
	declare -n VarRef="$1"
	declare Obj="$2"
	declare Start=${3:-"0"}
	declare Length=${4:-$($1.len)}
	
	printf "%s\n" "${VarRef:$Start:$Length}" | egrep -o "$Obj" | wc -l

	return 0
}	

function var.find()
{
	if [ ${#*} -gt 4 ]; then
		error_exit $LINE $FUNC "'${*:5}' Excesso de argumentos."
	elif [[ "$3" && "$3" != ?(+)+([0-9]) ]]; then
		error_exit $LINE $FUNC "Inicio: Precisa ser um inteiro positivo."
	elif [[ "$4" && "$4" != ?(+)+([0-9]) ]]; then
		error_exit $LINE $FUNC "Comprimento: Precisa ser um inteiro positivo."
	fi
	
	declare -n VarRef="$1"
	declare Obj="$2"
	declare Start=${3:-"0"}
	declare Length=${4:-$($1.len)}
	declare Swap=${VarRef:$Start:$Length}
	declare Swap2=${Swap/$Obj*}

	[ ${#Swap} -eq ${#Swap2} ] && echo -1 || echo $((${#Swap2}+1))

	return 0
}

function var.replace()
{
	if [ ${#*} -gt 4 ]; then
		error_exit $LINE $FUNC "'${*:5}' Excesso de argumentos."
	elif [[ "$4" && "$4" != ?(+)+([0-9]) ]]; then
		error_exit $LINE $FUNC "Maximo: Precisa ser um inteiro positivo."
	fi

	declare -n VarRef="$1"
	declare Old="$2"
	declare New="$3"
	declare -i Max=${4:-0}
	declare Obj="$VarRef"

	if [ $Max -eq 0 ]; then
		printf "%s\n" "$Obj" | sed "s/$Old/$New/g"
	else
		while [ $Max -gt 0 ]; do
			Obj="$(echo "$Obj" | sed "s/$Old/$New/")"
			((Max--)); done
		printf "%s\n" "$Obj"
	fi

	return 0

}

function var.mid()
{
	if [ ${#*} -gt 3 ]; then
		error_exit $LINE $FUNC "'${*:4}' Excesso de argumentos."
	elif [[ "$2" && "$2" != ?(+)+([0-9]) ]]; then
		error_exit $LINE $FUNC "Inicio: Precisa ser um inteiro positivo."
	elif [[ "$3" && "$3" != ?(+)+([0-9]) ]]; then
		error_exit $LINE $FUNC "Comprimento: Precisa ser um inteiro positivo."
	fi
	
	declare -n VarRef="$1"
	declare -i Start=${2:-0}
	declare -i Len=${3:-$($1.len)}

	printf "%s\n" "${VarRef:$Start:$Len}"

	return 0
	
}

function var.swapcase()
{
	if [ ${#*} -gt 2 ]; then
		error_exit $LINE $FUNC "'${*:3}' Excesso de argumentos."; fi
	
	declare -n VarRef="$1"
	printf "%s\n" "$VarRef" | sed 's/\([a-z]\)/[u]&/g;s/\([A-Z]\)/[l]&/g;s/\[l\]\(.\)/\L\1/g;s/\[u\]\(.\)/\U\1/g'
	
	return 0
}

function var.char()
{
	if [ ${#*} -gt 2 ]; then
		error_exit $LINE $FUNC "'${*:3}' Excesso de argumentos."
	elif [[ "$2" && "$2" != ?(+)+([0-9]) ]]; then
		error_exit $LINE $FUNC "Indice: Deve ser um inteiro positivo."
	fi
	
	declare -n VarRef="$1"
	declare -i Start=${2:-0}

	printf "%c\n" "${VarRef:$Start:1}"
	
	return 0
}

function var.squeeze()
{
	if [ ${#*} -gt 2 ]; then
		error_exit $LINE $FUNC "'${*:3}' Excesso de argumentos."
	elif [[ "$2" && "${#2}" -gt 1 ]]; then
		error_exit $LINE $FUNC "Caracterer: Deve ser único."
	fi
	
	declare -n VarRef="$1"
	declare Char="$2"

	printf "%s\n" "$VarRef" | tr -s "$Char"
	
	return 0
}

function var.left()
{
	if [ ${#*} -gt 2 ]; then
		error_exit $LINE $FUNC "'${*:3}' Excesso de argumentos."
	elif [[ "$2" && "$2" != ?(+)+([0-9]) ]]; then
		error_exit $LINE $FUNC "Comprimento: Deve ser um inteiro positivo."
	fi
	
	declare -n VarRef="$1"
	declare -i Len=$2
	
	printf "%s\n" "${VarRef:0:$Len}"

	return 0
}

function var.right()
{
	if [ ${#*} -gt 2 ]; then
		error_exit $LINE $FUNC "'${*:3}' Excesso de argumentos."
	elif [[ "$2" && "$2" != ?(+)+([0-9]) ]]; then
		error_exit $LINE $FUNC "Comprimento: Deve ser um inteiro positivo."
	fi
	
	declare -n VarRef="$1"
	declare -i Len='-'$2
	
	printf "%s\n" "${VarRef: $Len}"

	return 0
}

function var.repeat()
{
	if [ ${#*} -gt 2 ]; then
		error_exit $LINE $FUNC "'${*:3}' Excesso de argumentos."
	elif [[ "$2" && "$2" != ?(+)+([0-9]) ]]; then
		error_exit $LINE $FUNC "Quantidade: Deve ser um inteiro positivo."
	fi

	declare -n VarRef="$1"
	declare -i Rep=$2
	declare Obj

	while [ $Rep -gt 0 ]; do
		Obj+="$VarRef"; ((Rep--)); done
	
	printf "%s\n" "$Obj"
	
	return 0
}

function var.value()
{
	if [ ${#*} -gt 2 ]; then
		error_exit $LINE $FUNC "'${*:3}' Excesso de argumentos."; fi

	declare -n VarRef="$1"
	printf "%s\n" "$VarRef"

	return 0
}

function var.clear()
{
	if [ ${#*} -gt 1 ]; then
		error_exit $LINE $FUNC "'${*:2}' Excesso de argumentos."
	elif ! unset "$1" 2>/dev/null; then
			error_exit $LINE $FUNC "Variável somente leitura."; fi

	var "$1"
}

