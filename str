#!/bin/bash

# -----------------------------------------------------------------------------
#   Biblioteca: str (string)
#   Criado por: Juliano Santos
#   Data: 10 de Julho de 2016
#	Email: juliano.santos.bm@gmail.com
#  
#   A biblioteca contém funções para manipulação de strings e expressões,
#   no intuito de agilizar a automatizar o tratamento de cadeias de 
#	caracteres para diversas situações.
#   Seguindo um conceito de nomenclatura biblioteca.<função> para organização;
#	deixando o código legível e de fácil compreensão
#
#   Funções:
#
#   str.len, str.rev, str.split, str.replace, str.asc, str.chr, str.format
#	str.instr, str.tolower, str.toupper, str.left, str.right, str.comp,
#	str.dup, str.mod, str.cat, str.ncat, str.isdigit, str.isalpha, str.isupper
#	str.islower, str.isalnum str.filter
#
#   DOC:
#
#   A documentação da biblioteca está contida no arquivo 'str.hlp' no
#   diretório 'src'.
# ------------------------------------------------------------------------------
# Exit error
# set -e

# Bibliotecas externas
source me

# Checa se a biliboteca já foi inicializada.
if str.__INIT__ 2>/dev/null ; then
	return 1; fi

# Inicialização
function str.__INIT__() { return 0; }
function str.__NAME__() { echo $__STR_LIBRARY__; }
function str.__LIST__() { echo ${__STR_LIST__[*]}; }
function str.__CMD__(){ echo ${__STR_CMD__[*]}; }
#--------------------------------------------------------------------------------
# Constantes
declare -r __STR_LIBRARY__=str
# Método de comparação de strings.
# Passando como argumento nas funções, irá definir como a comparação entre strings
# seram intepretada.
# Tipos: METHOD_COMPARE_BINARY, METHOD_COMPARE_TEXT
# Notas:
#     	TEXT:	A diferença entre maíusculas e minúsculas seram ignoradas.
#				Será feita um conversão entre as strings para a mesma formatação,
#				tornando ambas iguais.
#		BINARY:	Haverá diferença entre caracteres maiúsculos e minúsculos.
#				Argumentos não seram convertidos e suas formatações mantidas.
declare -ir METHOD_COMPARE_BINARY=1
declare -ir METHOD_COMPARE_TEXT=2

# Base de notação da tabela ASCII
# Os caracteres poderam ser represetados por seus respectivos códigos.
# Códigos: DECIMAL, BINARIO, OCTAL E HEXADECIMAL
#			 DEC      BIN     OCT       HEX
declare -ir ASCII_DEC=1
declare -ir ASCII_OCT=2
declare -ir ASCII_HEX=3

# <str.filter>: Filtros
declare -ir FLT_ALNUM=1
declare -ir FLT_ALPHA=2
declare -ir FLT_CNTRL=3
declare -ir FLT_DIGIT=4
declare -ir FLT_GRAPH=5
declare -ir FLT_LOWER=6
declare -ir FLT_PUNCT=7
declare -ir FLT_UPPER=8
declare -ir FLT_PRINT=9


# Comandos
declare -ar __STR_CMD__=(
str.len
str.rev
str.split
str.replace
str.asc
str.chr
str.format
str.instr
str.tolower
str.toupper
str.left
str.right
str.comp
str.dup
str.mod
str.cat
str.ncat
str.isdigit
str.isalpha
str.isupper
str.islower
str.isalnum
str.filter
)

# Documentação
declare -ar __STR_LIST__=(
str.__INIT__
str.__NAME__
str.__LIST__
str.__CMD__
str.__HELP__
)

# Inicializa array de referẽncia. Contendo o valor decimal dos caracteres imprimiveis
# os Códigos são referenciados por seu caractere. 'a' = 97
declare -Ar ASCII=(
[' ']=32 ['!']=33 ['"']=34 ['#']=35 ['$']=36 ['%']=37 ['&']=38 ["'"]=39 ['(']=40 [')']=41 ['*']=42 ['+']=43 [',']=44 ['-']=45 ['.']=46 ['/']=47
['0']=48 ['1']=49 ['2']=50 ['3']=51 ['4']=52 ['5']=53 ['6']=54 ['7']=55 ['8']=56 ['9']=57 [':']=58 [';']=59 ['<']=60 ['=']=61 ['>']=62 ['?']=63
['@']=64 ['A']=65 ['B']=66 ['C']=67 ['D']=68 ['E']=69 ['F']=70 ['G']=71 ['H']=72 ['I']=73 ['J']=74 ['K']=75 ['L']=76 ['M']=77 ['N']=78 ['O']=79
['P']=80 ['Q']=81 ['R']=82 ['S']=83 ['T']=84 ['U']=85 ['V']=86 ['W']=87 ['X']=88 ['Y']=89 ['Z']=90 ['[']=91 ['\']=92 [']']=93 ['^']=94 ['_']=95
['`']=96 ['a']=97 ['b']=98 ['c']=99 ['d']=100 ['e']=101 ['f']=102 ['g']=103 ['h']=104 ['i']=105 ['j']=106 ['k']=107 ['l']=108 ['m']=109 ['n']=110
['o']=111 ['p']=112 ['q']=113 ['r']=114 ['s']=115 ['t']=116 ['u']=117 ['v']=118 ['w']=119 ['x']=120 ['y']=121 ['z']=122 ['{']=123 ['|']=124 ['}']=125
['~']=126
)
#---------------------------------------------------------------------------------

function str.len()
{
	# str.len expressão
	# Max. Args: 1
	# Checa o número de argumentos passados.
	[ ${#@} -gt 1 ] && 	error_exit $BASH_LINENO $FUNCNAME "'${*:2}' Excesso de argumentos."
	
	# Imprime comprimento da string
	echo ${#1}

	# status
	return 0
}

function str.rev()
{
	# str.rev expressão
	# Max. Args: 1
	[ ${#@} -gt 1 ] && 	error_exit $BASH_LINENO $FUNCNAME "'${*:2}' Excesso de argumentos."

	# Variaveis
	local Expression="$1"
		
	# Verifica se a expressão é nula
	[ ! "$Expression" ] && error_exit $BASH_LINENO $FUNCNAME "Expressão: Cadeia de caracteres não pode ser nula."

	# Imprima saida invertida.
	echo -e "$Expression" | rev 
	
	# status

	return 0
}

function str.split()
{
	# str.split expressão delimitador variavel comparação
	# Nax. Args: 4
	# Opcional: 1
	# Checa o número de argumentos passados. 
	[ ${#@} -gt 4 ] && error_exit $BASH_LINENO $FUNCNAME "'${*:5}' Excesso de argumentos."

	# Variaveis locais.
	local Expression="$1"
	local Delimiter="$2"
	local Variable="$3"
	local -i CompareType="${4:-$METHOD_COMPARE_BINARY}"  # Se "CompareType" for nula, define Valor padrão = 1
	local CharS
	
	# Trata os argumentos passados na função.
	if [ ! "$Expression" ]; then
		error_exit $BASH_LINENO $FUNCNAME "Expressão: Cadeia de caracteres não pode ser nula."
	elif [ ! "$Delimiter" -o ${#Delimiter} -gt 1 ]; then
		error_exit $BASH_LINENO $FUNCNAME "Delimitador: Precisa ser caractere único."
	elif [ ! "$Variable" ]; then
		error_exit $BASH_LINENO $FUNCNAME "Variável: Requer nome."
	elif [ $CompareType -eq $METHOD_COMPARE_TEXT ]; then
		CharS='I'
	elif [ $CompareType -eq $METHOD_COMPARE_BINARY ]; then
		CharS=''
	else
		error_exit $BASH_LINENO $FUNCNAME "Comparação: Valor do método inválido.";
	fi
	
	# Monta a estrutura do array, separando os campos pelo seu delimitador, atribui a estrutura
	# a variavel passada em '$4' e executa a estrutura para alocação dos elementos.
	if ! eval $Variable=$(echo "$Expression" | sed "s/^/(\"/;s/$/\")/;s/$Delimiter/\" \"/$CharS g") 2>/dev/null; then
		error_exit $BASH_LINENO $FUNCNAME
	fi

	# status
	return 0
	
}

function str.replace()
{
	# sintaxe: str.replace expressão pesquisa substituição metodo
	# Max Args: 4
	# Opcional: 1
	# Checa o número de argumentos passados
	[ ${#@} -gt 4 ] && error_exit $BASH_LINENO $FUNCNAME "'${*:5}' Excesso de argumentos."

	# Variavel local
	local Expression="$1"
	local Search="$2"
	local Replace="$3"
	local -i CompareType="${4:-$METHOD_COMPARE_BINARY}" # Se "CompareType for nula, define valor padrão = 1
	local CharS
	
	# Verifica e trata os argumentos passados na função.	
	if [ ! "$Expression" ]; then
		error_exit $BASH_LINENO $FUNCNAME "Expressão: Cadeia de caracteres não pode ser nula."
	elif [ ! "$Search" ]; then
		error_exit $BASH_LINENO $FUNCNAME "Pesquisa: Sequẽncia de caracteres não pode ser nula."
	#elif [ ! "$Replace" ]; then
	#	error_exit $BASH_LINENO $FUNCNAME "Subsituição: Sequẽncia de caracteres não pode ser nula."
	elif [ $CompareType -eq $METHOD_COMPARE_TEXT ]; then
		CharS='I'
	elif [ $CompareType -eq $METHOD_COMPARE_BINARY ]; then
		CharS=''
	else
		error_exit $BASH_LINENO $FUNCNAME "Comparação: Valor do método inválido."
	fi

	# Aplica a substituição e imprime na saida. 
	echo "$Expression" | sed "s/$Search/$Replace/$CharS g"
	
	# status
	return 0	
		
}

function str.asc()
{
	# str.asc caractere base 
	# Max. Args: 2
	# Opcional: 1
	# Checa o número de argumentos passados.
	[ ${#@} -gt 2 ] && error_exit $BASH_LINENO $FUNCNAME "'${*:3}' Excesso de argumentos."

	# Variavel local
	local Char="$1"
	local -i Base=${2:-$ASCII_DEC}	# Se "Base" for nula, define o valor padrão = 1

	# Trata os argumentos passados na função
	if [ ! "$Char" -o ${#Char} -gt 1 ]; then
		error_exit $BASH_LINENO $FUNCNAME "Caractere: Deve ser caractere único."
	elif [ $Base -eq $ASCII_DEC ]; then
		printf "%d\r\n" ${ASCII["$Char"]} 		
	elif [ $Base -eq $ASCII_OCT ]; then
		printf "%03o\r\n" ${ASCII["$Char"]}
	elif [ $Base -eq $ASCII_HEX ]; then
		printf "x%02x\r\n" ${ASCII["$Char"]}
	else
		error_exit $BASH_LINENO $FUNCNAME "Base: Valor de base inválido."
	fi
	
	# status
	return 0
}

function str.chr()
{
	# str.asc caractere base 
	# Max. Args: 2
	# Opcional: 1
	# Checa o número de argumentos passados na função.
	[ ${#@} -gt 2 ] && error_exit $BASH_LINENO $FUNCNAME "'${*:3}' Excesso de argumentos."

	# Variavel local
	local Code="$1"
	local -i Base=${2:-$ASCII_DEC}	# Se "Base" for nulo, define o valor padrão.

	# Verifica os argumentos
	# Em 'Base' do tipo ASCII_HEX, verifica-se os caracteres são válidos.
	if [[ ! "$Code" || "$Code" != ?(+)+([0-9-a-fA-Fx]) ]]; then
		error_exit $BASH_LINENO $FUNCNAME "Código: Valor inserido inválido."
	elif [ $Base -eq $ASCII_DEC ]; then
		printf \\$(printf "x%02x" "$Code")
	elif [ $Base -eq $ASCII_OCT ]; then
		printf "\\$Code\r\n"
	elif [ $Base -eq $ASCII_HEX ]; then
		printf "\\$Code\r\n"
	else
		error_exit $BASH_LINENO $FUNCNAME "Base: Valor de base inválido."
	fi
	
	# status
	return 0	
	
}

function str.format()
{
	# str.format expressão formato
	# Nax. Args: 2
	# Verifica o número de argumentos passados.
	[ ${#@} -gt 2 ] && error_exit $BASH_LINENO $FUNCNAME "'${*:3}' Excesso de argumentos."
		
	# Variavel local
	local Expression="$1"
	local Format="$2"
	local StrSwap
	local -i VExp VFmt

	# Verifica os argumentos passados na função
	if [ ! "$Expression" ]; then
		error_exit $BASH_LINENO $FUNCNAME "Expressão: Não pode ser nula."
	elif [ ! "$Format" ]; then
		error_exit $BASH_LINENO $FUNCNAME "Formato: não pode ser nulo."
	fi
				
	# Lẽ o tamanho do indice de 'formato'
	for VFmt in $(seq 0 $((${#Format}-1)))
	do
		# Lẽ o caractere na posição 'VExp' em 'Expression', se for igual a 'espaço' incrementa o valor de 'VExp'
		# Lẽ o caractere na posição 'VFmt' em 'Format", se for igual ao caractere curinga "#", Incrementa a string
		# "StrSwap" com o caractere da posição 'VExp' em Expression. Subsituindo o caractere curinga e incrementa o valor de 'VExp'
		# passando para o próximo caracter em 'Format'
		# Incrementa 'StrSwap' com o caractere da posição 'VFmt' em 'Format'
		# Notas:
		# 	Aplica-se a substituição somente nos caractere(s) coringa(s) "#" contidos em 'Format' pelos caracteres contidos em
		#   'Expression'. Em ambos, o(s) 'espaço(s)' são ignorados.
		if [ "${Expression:$VExp:1}" == " " ]; then
			((VExp++))
		elif [ "${Format:$VFmt:1}" == "#" ]; then
			StrSwap+="${Expression:$VExp:1}"
			((VExp++))
			# Faz um salto no loop para o próximo elemento.
			continue
		fi

		# Incrementa 'StrSwap'
		StrSwap+="${Format:$VFmt:1}"
	done 	

	# Imprime	
	echo $StrSwap

	# status
	return 0
}

function str.instr()
{
	# str.instr caractere expressão metodo
	# Max. Args: 3
	# Opcional: 1
	# Lẽ o número de argumentos passados.
	[ ${#@} -gt 3 ] && error_exit $BASH_LINENO $FUNCNAME "'${*:4}' Excesso de argumentos."
	
	# Variavel local.
	local Char="$1"
	local Expression="$2"
	local -i CompareType=${3:-$METHOD_COMPARE_BINARY}	# Se 'Comparetype' for nulo, define o valor padrão = 1
	local -i Match=-1	# Valor padrão
	local cLower cUpper VExp
	
	# Trata os argumentos da função.
	if [ ! "$Char" -o  ${#Char} -gt 1 ]; then
		error_exit $BASH_LINENO $FUNCNAME "Caractere: Deve ser um único caractere."
	elif [ ! "$Expression" ]; then
		error_exit $BASH_LINENO $FUNCNAME "Expressão: não pode ser nula."
	# Se método for '$METHOD_COMPARE_TEXT', converte o caractere passado na função para o oposto da sua formação
	# [a-z] -> [A-Z] ou [A-Z] -> [a-z], alocando-o na variavel.
	# Descrição:
	# 		a -> aA ou A -> Aa
	# Com essa conversão cria-se um filtro para ignorar a diferença de minúsculas para maiúsculas.
	elif [ $CompareType -eq $METHOD_COMPARE_TEXT ]; then
		cLower="$(echo "$Char" | tr '[:upper:]' '[:lower:]')" # Minúsculo
		cUpper="$(echo "$Char" | tr '[:lower:]' '[:upper:]')" # Maiúsculo
		Char="$cLower|$cUpper" # Armazena as formatações.
	elif [ $CompareType -ne $METHOD_COMPARE_BINARY ]; then
		error_exit $BASH_LINENO $FUNCNAME "Comparação: Valor do método inválido."
	fi
	
	# Lẽ os caracteres em 'Expression'.
	for VExp in $(seq 0 $((${#Expression}-1)))
	do
		# Se o caractere na posição 'VExp' em 'Expression' for igual 'Char'
		# armazena a posição do caractere em 'Match' e sai do loop
		if [[ "${Expression:$VExp:1}" == ?($Char) ]]; then
			Match=$VExp
			break
		fi
	done
	
	# Imprime o valor armazenado em Match
	# -1 : Não encontrado
	# > -1: Posição encontrada.
	echo $Match

	# status
	return 0

}

function str.tolower()
{
	# str.tolower expressão
	# Max. Args: 1
	
	# Lê o número de argumentos passados e trata 
	if [ ${#@} -gt 1 ]; then
		error_exit $BASH_LINENO $FUNCNAME "'${*:2}' Excesso de argumentos."
	elif [ ! "$1" ]; then
		error_exit $BASH_LINENO $FUNCNAME "Expressão: não poder ser nula."
	fi
	
	# Imprime a conversão 
	echo "$1" | tr '[:upper:]' '[:lower:]'
	
	# status
	return 0
			
}

function str.toupper()
{
	# str.tolower expressão
	# Max. Args: 1
	
	# Lê número de argumentos e trata 
	if [ ${#@} -gt 1 ]; then
		error_exit $BASH_LINENO $FUNCNAME "'${*:2}' Excesso de argumentos."
	elif [ ! "$1" ]; then
		error_exit $BASH_LINENO $FUNCNAME "Expressão: não poder ser nula."
	fi

	# Imprime a conversão 
	echo "$1" | tr '[:lower:]' '[:upper:]'
	
	# status
	return 0
			
}

function str.left()
{
	# str.left expressão comprimento
	# Max. Args: 2
	# Opcional: 1
	# Lẽ o número de argumentos passados.
	[ ${#@} -gt 2 ] && error_exit $BASH_LINENO $FUNCNAME "'${*:3}' Excesso de argumentos."

	# Variável local
	local Expression="$1"
	local -i Length=${2:-${#Expression}} # Se 'Length' for nula, define o valor padrão = comprimento taotal de 'Expression'
	
	# Trata o argumento.
	if [ ! "$Expression" ]; then
		error_exit $BASH_LINENO $FUNCNAME "Expressão: Não poder ser nula."
	fi

	# Imprime os primeiros 'Length' caracteres de 'Expression' 
	echo "${Expression:0:$Length}"
	
	# status
	return 0
}

function str.right()
{
	# str.right expressão comprimento
	# Max. Args: 2
	# Opcional: 1
	# Lẽ o número de argumentos
	[ ${#@} -gt 2 ] && error_exit $BASH_LINENO $FUNCNAME "'${*:3}' Excesso de argumentos."

	# Variavel local
	local Expression="$1"
	local -i Length=${2:-${#Expression}} # Se 'Length' for nula, define o valor padrão = comprimento total de 'Expression'
	
	# Trata o argumento
	if [ ! "$Expression" ]; then
		error_exit $BASH_LINENO $FUNCNAME "Expressão: Não poder ser nula."
	fi
	
	# Adiciona o sinal '-' para leitura reversa da expressão	
	Length='-'$Length

	# Imprime os últimos 'Length' caracteres de 'Expression'
	echo "${Expression: $Length}"
	
	# status
	return 0
}

function str.comp()
{
	# str.comp string1 string2 metodo
	# Max. Args: 3
	# Opcional: 1
	# Lẽ o número de argumentos passados.
	[ ${#@} -gt 3 ] && error_exit $BASH_LINENO $FUNCNAME "'${*:4}' Excesso de argumentos."

	# Variavel local
	local StringA="$1"
	local StringB="$2"
	local -i CompareType=${3:-$METHOD_COMPARE_BINARY} # Se 'CompareType' for nula, define valor padrão = 1

	# Trata os argumentos
	if [ ! "$StringA" -o ! "$StringB" ]; then
		error_exit $BASH_LINENO $FUNCNAME "String: Não pode ser nula."
	elif [ $CompareType -eq $METHOD_COMPARE_TEXT ]; then
		# Método de comparação: $METHOD_COMPARE_TEXT
		# Realiza duas conversões de formatação nas strings contindas em ambos argumentos 'StringA' e 'StringB'
		# Fazendo com que ambas fiquem minúsculas e as diferenças entre formatações sejam eliminadas.
		# Exemplo:
		# 		StringA="var"; StringB="VAR"
		#
		#       StringA:  var -> VAR -> var 
		#       StringB:  VAR -> var -> var 
		#
		StringA="$(echo "$StringA" | tr '[:lower:]' '[:upper:]' | tr '[:upper:]' '[:lower:]')" 
		StringB="$(echo "$StringB" | tr '[:lower:]' '[:upper:]' | tr '[:upper:]' '[:lower:]')"
	elif [ $CompareType -ne $METHOD_COMPARE_BINARY ]; then
		error_exit $BASH_LINENO $FUNCNAME "Comparação: Valor do método inválido."
	fi

	# Imprime
	# 0 - Iguais
	# 1 - Diferentes
	[[ "$StringA" == "$StringB" ]]  && echo 0 || echo 1
	
	# status
	return 0	
}

function str.dup()
{
	# str.dup string quantidade
	# Max. Args: 2
	# Opcional: 1
	# Lẽ o número de argumentos
	[ ${#@} -gt 2 ] && error_exit $BASH_LINENO $FUNCNAME "'${*:3}' Excesso de argumentos."
	
	# Variavel local
	local -i Number=${2:-1} # Se 'Number' for nulo, define o valor padrão = 1
	local String="$1"
	local StrSwap
	local -i Cont

	# Trata o argumento.
	if [ ! "$String" ]; then
		error_exit $BASH_LINENO $FUNCNAME "Expressão: Não poder ser nula."
	fi

	# Incrementa 'StrSwap' com "String" 'Number' vezes. 
	for ((Cont=1; $Cont <= $Number; Cont++)); do StrSwap+="$String"; done
		
	# Imprime
	echo $StrSwap
	
	# status
	return 0
}

function str.mod()
{
	# str.mod expressao inicio comprimento
	# Max. Args: 3
	# Opcional: 2
	# Lẽ o número de argumentos.
	[ ${#@} -gt 3 ] && error_exit $BASH_LINENO $FUNCNAME "'${*:4}' Excesso de argumentos."

	# Variavel local
	local Expression="$1"
	local -i Start=${2:-0}	# Se 'Start' for nula, define valor padrão = 0
	local -i Length=${3:-${#Expression}}	# Se 'Length' for nula, define valor padrão = comprimento total de 'Expression'

	# Trata argumento
	if [ ! "$Expression" ]; then
		error_exit $BASH_LINENO $FUNCNAME "Expressão: Não poder ser nula."
	fi

	# Imprime 'Expression' apartir da posição 'Start' e comprimento 'Length'
	echo "${Expression:$Start:$Length}"

	# status
	return 0
	
}

function str.cat()
{
	# str.cat variavel expressão
	# Max. Args: 2
	# Lẽ o número de argumentos.
	[ ${#@} -gt 2 ] && error_exit $BASH_LINENO $FUNCNAME "'${*:3}' Excesso de argumentos."

	# Variavel local
	local Var="$1"
	local Expression="$2"

	# Trata argumentos.
	if [ ! "$Var" ]; then
		error_exit $BASH_LINENO $FUNCNAME "Variavel: Requer nome."
	elif [ ! "$Expression" ]; then
		error_exit $BASH_LINENO $FUNCNAME "Expressão: Nâo pode ser nula."
	fi

	# Concatena	
	eval $Var+="'$Expression'"

	# status
	return 0
	
}

function str.ncat()
{
	# str.cat variavel expressão comprimento
	# Max. Args: 3
	# Opcional: 1
	# Lê o número de argumentos.
	[ ${#@} -gt 3 ] && error_exit $BASH_LINENO $FUNCNAME "'${*:4}' Excesso de argumentos."

	# Variavel local.
	local Var="$1"
	local Expression="$2"
	local -i Length=${3:-${#Expression}}	# Se 'Length' for nula, define o valor padrão = comprimento total de 'Expression'

	# Trata argumentos.
	if [ ! "$Var" ]; then
		error_exit $BASH_LINENO $FUNCNAME "Variavel: Requer nome."
	elif [ ! "$Expression" ]; then
		error_exit $BASH_LINENO $FUNCNAME "Expressão: Nâo pode ser nula."
	fi
	
	# Incrementa 'Var' com os primeiros 'Length' caracteres de 'Expression'
	eval $Var+="'${Expression:0:$Length}'" 

	# status
	return 0
	
}

function str.isdigit()
{
	# str.isdigit expressão
	# Max. Args: 1
	# Lẽ o número de argumentos.
	[ ${#@} -gt 1 ] && error_exit $BASH_LINENO $FUNCNAME "'${*:2}' Excesso de argumentos."

	# Variavel local
	local Expression="$1"
	local -i RetVal

	# Trata o argumento	
	if [ ! "$Expression" ]; then
		RetVal=-1
	# Se 'Expression' for nula após remover todos os digitos,
	# significa que o conteúdo de 'Expression' é somente digito.
	elif [ ! "$(echo "$Expression" | tr -d '[:digit:]')" ]; then 
		RetVal=0
	else
		RetVal=1
	fi 
	
	# Imprime o valor de 'RetVal'
	# -1 - Nula
	#  0 - É digito
	#  1 - Não é digito
	echo $RetVal
	
	return 0
	
}

function str.isalpha()
{
	# str.isalpha expressão
	# Max. Args: 1
	# Lẽ o número de argumentos
	[ ${#@} -gt 1 ] && error_exit $BASH_LINENO $FUNCNAME "'${*:2}' Excesso de argumentos."

	# Variavel local
	local Expression="$1"
	local -i RetVal
	
	if [ ! "$Expression" ]; then
		RetVal=-1
	# Se 'Expression' for nula após remover todos os caracteres a-zA-Z,
	# significa que o conteúdo de 'Expression' é Alpha.
	elif [ ! "$(echo "$Expression" | tr -d '[:alpha:]')" ]; then
		RetVal=0
	else
		RetVal=1
	fi 
	
	# Imrime o valor de 'RetVal'
	# -1 - Nula
	#  0 - É Alpha
	#  1 - Nâo é Alpha
	echo $RetVal
	
	return 0
	
}

function str.islower()
{
	# str.islower expressão
	# Max. Args: 1
	# Lẽ o número de argumentos
	[ ${#@} -gt 1 ] && error_exit $BASH_LINENO $FUNCNAME "'${*:2}' Excesso de argumentos."

	# Variável local
	local Expression="$1"
	local -i RetVal
	
	# Trata argumento
	if [ ! "$Expression" ]; then
		RetVal=-1
	# Se 'Expression' for nula após remover todos os caracteres minúsculos,
	# significa que o conteúdo de 'Expression' é minúsculo.
	elif [ ! "$(echo "$Expression" | tr -d '[:lower:]')" ]; then
		RetVal=0
	else
		RetVal=1
	fi 
	
	# Imrime o valor de 'RetVal'
	# -1 - Nula
	#  0 - É Minúsculo
	#  1 - Nâo é Minúsculo
	echo $RetVal
	
	return 0
	
}

function str.isupper()
{
	# str.isupper expressão
	# Max. Args: 1
	# Lẽ o número de argumentos
	[ ${#@} -gt 1 ] && error_exit $BASH_LINENO $FUNCNAME "'${*:2}' Excesso de argumentos."

	# Variável local
	local Expression="$1"
	local -i RetVal
	
	if [ ! "$Expression" ]; then
		RetVal=-1
	# Se 'Expression' for nula após remover todos os caracteres Maiúsculos,
	# significa que o conteúdo de 'Expression' é maiúculo.
	elif [ ! "$(echo "$Expression" | tr -d '[:upper:]')" ]; then
		RetVal=0
	else
		RetVal=1
	fi 
	
	# Imrime o valor de 'RetVal'
	# -1 - Nula
	#  0 - É Maiúsculo
	#  1 - Nâo é Maiúsculo
	echo $RetVal
	
	return 0
	
}

function str.isalnum()
{
	# str.isalnum expressão
	# Max. Args: 1
	# Lẽ o número de argumentos.
	[ ${#@} -gt 1 ] && error_exit $BASH_LINENO $FUNCNAME "'${*:2}' Excesso de argumentos."
	
	# Variavel local
	local Expression="$1"
	local -i RetVal
	
	# Trata argumento.
	if [ ! "$Expression" ]; then
		RetVal=-1
	# Se 'Expression' for nula após remover todos os caracteres e digitos,
	# significa que o conteúdo de 'Expression' é Alpha numérico.
	elif [ ! "$(echo "$Expression" | tr -d '[:alnum:]')" ]; then
		RetVal=0
	else
		RetVal=1
	fi 
	
	# Imrime o valor de 'RetVal'
	# -1 - Nula
	#  0 - É Alpha numérico
	#  1 - Nâo é Alpha numérico
	echo $RetVal
	
	return 0
	
}

function str.filter()
{
	# str.filter expressão caracteres filtro
	# Max. Args: 10
	# Opcional: 2
	[ ${#@} -gt 10 ] && error_exit $BASH_LINENO $FUNCNAME "'${*:11}' Excesso de argumentos."

	# Variavel local	
	local Expression="$1"
	local Char="$2"
	local -ia Filter=(${*:3})

	# Se filter for nulo, define o valor padrão = 9
	Filter=${Filter:-$FLT_PRINT}

	# Trata argumento
	if [ ! "$Expression" ]; then
		error_exit $BASH_LINENO $FUNCNAME "Expressão: Não pode ser nula."
	fi 
	
	# Lẽ os filtros	
	for FTL in ${Filter[*]}
	do
		# Se valor de 'FTL' estiver na seleção
		# incrementa 'eFilter' com a expressão correspondente.
		case $FTL in						# Lẽ o valor
			$FLT_ALNUM)						#	1
				eFilter+="[[:alnum:]]{1,}|" 
				;;
			$FLT_ALPHA)						#	2
				eFilter+="[[:alpha:]]{1,}|" 
				;;
			$FLT_CNTRL)						#	3
				eFilter+="[[:cntrl:]]{1,}|"
				;;
			$FLT_DIGIT)						# 	4
				eFilter+="[[:digit:]]{1,}|"
				;;
			$FLT_GRAPH)						#	5
				eFilter+="[[:graph:]]{1,}|"
				;;
			$FLT_LOWER)						#	6
				eFilter+="[[:lower:]]{1,}|"
				;;
			$FLT_PUNCT)						#	7
				eFilter+="[[:punct:]]{1,}|"
				;;
			$FLT_UPPER)						#	8
				eFilter+="[[:upper:]]{1,}|"
				;;
			$FLT_PRINT)						#	9
				eFilter+="[[:print:]]{1,}|"
				;;	
			*)
				# Nehum dos valores acima.
				error_exit $BASH_LINENO $FUNCNAME "Filtro: Valor inválido."
				return 0
				;;
		esac
	done
	
	# Se 'Char' não for nulo, incrementa 'eFilter' com o valor de 'Char'
	[ $Char ] && eFilter+="[$Char]{1,}"

	# Desabilita a cor de seleção do grep
	GREP_COLOR=never

	# Filtra 'Expression' com a expressão em 'eFilter' e imprime 
	echo "$Expression" | egrep --no-messages --only-matching "$eFilter" | tr '\n' ' ' | sed 's/$/\n/'

	# Reset
	unset GREP_COLOR

	# Status
	return 0
	
}

# Registra funções e intruções somente leitura
declare -rxf ${__STR_LIST__[*]}
declare -rxf ${__STR_CMD__[*]}

